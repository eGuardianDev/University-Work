# Предсказващ синтактичен анализатор

## Предсказващ синтактичен анализатор

LL(k) - изпозлва следващите k синвула
- left-to-right scan
- left-most derivation

### 1. предсказващ синтактичен анализ 
обикновено има множество потенциални правила.
При LL(1) има само едно вярно правило.

---
ωAβ 

ако имаме следващ жетон от входа t и има само едно вярно правило A → α

тогава става ωαβ

--- 
трябва граматика да е преобразуване чрез ляво извличане

---

E → TX; 

X → + E | ε

T → int Y | ( E );

Y → * T | ε

|   | int  | *    | +    | (    | )    | $    |
|---|------|------|------|------|------|------|
| **E** | T X |      |      | T X |      |      |
| **X** |      |      | + E |      | ε    | ε    |
| **T** | int Y |      |      | (E) |      |      |
| **Y** |      | * T | ε    |      | ε    | ε    |

---
- стек (необратими нетерминали и непрочетени терминали)
- празна клетка - отхвърля кода
- приема входа - ако стигне до края на низа и стека е празен


## 2. първи множества

- t е терминал => First(t) = {t}
- X е нетерминал => $First(X) = First(X)-\{\epsilon\}$
- X -> a => $First(a) \sube First(X)$  
- X -> $\epsilon$ => $\epsilon \in$ First(x) 


```
E → TX; X → + E | ε
T → int Y | ( E ); Y → * T | ε
First('+') = { + }
First('*') = { * }   
First(int) = { int } 
First('(') = { ( }   
First(')') = { ) }
First($) = { $ }

First(Y) = { *,  ε }
First(T) = { int, ( }
First(E) ⊇ First(TX) ⊇ First(T) 
First(E) = { int, ( }

First(X) = { + }
```

## 3. следващи множества

- ако X → AB, значи Follow(A) ⊇ First(B)
- но също така и Follow(B) ⊇ Follow(X)
- ако B →* ε, тогава Follow(A) ⊇ Follow(X)
- Ако S е началния символ, тогава $ ∈ Follow(S)