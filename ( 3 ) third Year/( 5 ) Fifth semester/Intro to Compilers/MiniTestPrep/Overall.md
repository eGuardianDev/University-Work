

## подробна работа на алгоритъма за рекурсивно спускане;

1. Почва се с началния синвол. 
2. Заместваме с правило.
    - ако има нетерминал, правим (2.)
    - ако има терминал, сравняваме с входа
        - ако съвпада, продължаваме
        - ако не, backtracking и пробваме с друга трансформация

- ако сме генерали дърво и сме минали през всички синволи: Готови сме!
- ако не сме: Думата не е разпозната! 

## LL(1)

дефиниция: една граматика е LL(1), ако всяко поле от
LL(1) таблицата за нея не съдържа повече от един
запис

Причини:
- граматиката не е ляво-извлечена 
    - ако има first-first conflict $A → a β₁ | a β₂$
- граматиката е ляво-рекурсивна
    - ако имаме A ->* A $\alpha$
- граматиката е нееднозначна
    - граматики, който генерират различни дървета
    - $E → E + E | E * E | id$
    - `id + id * id` има няколко дървета за създаване


## LR(1)
Ако граматиката има конфликти от вида:
- изместване-опростяване (shift-reduce)
- опростяване-опростяване (reduce-reduce)

то тя не е LR(1)


## SLR(1)
Отново има Shift-Reduce, Reduce-Reduce конфликти


## other

Как да различин --- Възходящ синтактичен анализ:
- четеш отдолу нагоре и винаги сменяш най-дясната транформация
- изместван и опростяване се нарича


Конфликти при тези анализи:
- изместване-опростяване:
    - имаме две правила, едното е готова за заменяне, другото може да продължи да измества
```
 S → if E then S;
   | if E then S else S;
   | other
```
- опростяване-опростяване:
    - ако разгледаме автомата, може да има две възможни опростявания (тоест правила $ A\rightarrow a|b$) Това е по-проблемно от горното



##  ляво-извлечени граматики, ляво-рекурсивни граматики, нееднозначни граматики, LL(1) граматики, SLR(1) граматики, LALR(1) граматики и разликата между тях.

LARL(k) може да се изведе `handler` или `показалец`

#### Парче
Когато домабим точка между всеки синвол в едно правило.

- Съшо трябва да добавим `S'->начално правило`
- Ако имаме буква и в нашето правило, отдясно на точката е буквата, местим с тази дума точката надясно и влизаме в ново състояние.
- ако може от дадоно състояние `T->.A` има `A->int` може да направим с $\epsilon$ от `T->.A` към `А->.int` (внимвай с точката)
- всяко състояние е приемащо

#### Автомата

Ако вкараме дадено парче в автомата, и той го приеме, значи е `показалец` и възможните следващи неща са правилата в състоянието. Например ако в състоянието има `T->T+.E`, тогава възможно е да следва `E`. 



### other

`LL(1)  ⊂  SLR(1)  ⊂  LALR(1)  ⊂  LR(1)`



## Kратко резюме (перфектно за изпит)

- Лява рекурсия: A ⇒⁺ Aα. Забранява LL(1).

- Ляво-извлечена: няма общи префикси. Нужно за LL(1).

- Нееднозначна: има повече от едно дърво за някоя дума. Забранява LL и LR.

- LL(1): никакви FIRST/FIRST или FIRST/FOLLOW конфликти.

- SLR(1): LR(0) + FOLLOW. Може да има излишни конфликти.

- LALR(1): почти LR(1) сила, но компактни таблици.

- Йерархия: LL(1) ⊂ SLR(1) ⊂ LALR(1) ⊂ LR(1).




## конфликти
- LR(1) граматики нямат никакви конфликти, (✔ LR(1) ≡ “най-мощният практически метод, без конфликти”.)
- SLR(1) може да има,
- LR(0) почти винаги има. 