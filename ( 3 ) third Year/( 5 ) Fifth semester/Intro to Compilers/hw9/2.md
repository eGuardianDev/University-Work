# Изрази

```
E(id) = l id
S(l id) = v
so, E, S ⊦ id : v, S
```

```
so, E, S ⊦ self : so, S
```

трябва да алокираме ново място в storage
l_new = newloc(S)

# Създаване на обект

default стойности (А е клас)
 - D_int = Int(0)
 - D_bool = Bool(false)
 - D_string = String(0, "")
 - D_A = void




class(A) = (a_1 : T_1 ← e_1, ..., a_n : T_n ← e_n)

a-тата са атрибути вкл и наследени



- 3 стъпки заделяме памет
- останалите са инициализиране на обекта
    - атрибутите са в област на видимост
    - self е обекта, който се създава


# Динамично извикване

e_0.f(e_1, ..., e_n)

1. смятаме e_1, ..., e_n
2. изчисляваме стойност e_0 => обект t от тип X
3. намираме дефиниция на f в X
4. създаваме n нови локации в хранилището и свъзваме аругментите с тях
5. инизиализираме default резултати
6. присвояваме self на t
7. изчисляваме тялото на f


impl(A,f) = (x_1, ..., x_n,e_body)
 - x_1 ... x_n имена на аргументи
 - е_body е тяло на метода