# Sorting algorthims


Легенда

 - ![#f03c15](https://placehold.co/15x15/f03c15/f03c15.png) -> Това прави алгоритъма добър
 - (?) –> не помня защо това е така
 - (*) -> уловка, зависи от нещо (??? за повечето не съм сигурен от какво обаче)
---
 - общ - Може да се използва при всякакви данни
 - присвояване - колко време отнема на алгоритъма да се приключи
 - сравнение - ?? мисля че е всеки елемент как се сравнява с другите / колко време е нужно да се намери правилното място или нещо катова
 - памет - колко нова памет трябва да създаде
 - стабилност - дали запазва реда на елементите (ако два елемента имат еднаква стойност, те да излезнат както са влезнали. Например вкарваме 3,1,2[1],5,2[2] и ги сортираме. Получаваме 1,2[1],2[2],3,5. Тук двойките са подредени както са влезли.)
 - частичност - дали може да се изчислят само върху отделни данни или част от подадедените данни
 - локалност - дали се възползва от cache паметта на процесора (дали достъпените данни са едни до други)
 - адаптивност - дали алгоритъма може сам да се оптимизира (ако намери връзка между данните, да избере друг подход. Например ако имаме само 1,1,1,1,1,.... 1, тогава няма нужда от сортиране или алгоритъма спира)
 - устоичивост - не съм сигурен
 - зависимост от контейнера - какво адресиране на данните е необходимо
 - паралелизуемост - дали може да се раздели процесора на няколко ядра/компютъра
---
|Име|Selection Sort | Insertion Sort | Buble Sort | Shell|
|---|---|---|---|---|
|Общ?|да|да|да|да|
|**Присвояване**|||||
|*Best*|O|O  ![#f03c15](https://placehold.co/15x15/f03c15/f03c15.png)|O|O|
|*Average*|O(n)|O(n^2)|O(n^2)|O(n*log(n))|
|*Worst*|O(n)  ![#f03c15](https://placehold.co/15x15/f03c15/f03c15.png)|O(n^2)|O(n^2)|O(n*log(n))|
|**Сравняване**|||||
|*min*|O(n^2)|O(n)  ![#f03c15](https://placehold.co/15x15/f03c15/f03c15.png)|O(n^2)|O(n)|
|*max*|O(n^2)|O(n^2)|O(n^2)|O(n*log(n))|
|**памет**|O(1)|O(1)|O(1)|O(1)|
||||||
|стабилност|не|да|да|не|
|частичност|да|не|да|не|
|локалност|да|да(*)|да|не|
|поточност|не|да ![#f03c15](https://placehold.co/15x15/f03c15/f03c15.png)|не|не|
|адаптивност|по присвояване| да (силно)  ![#f03c15](https://placehold.co/15x15/f03c15/f03c15.png)| да|да|
|устоичивост|по сравнение|не|не|не|
|взависимост от контейнера|последен достъп| почти добре (локален)|почти добре (локален)|пряк|
|паралелизуемост|не|не|силно* (в основата на паралелни алгоритми)|не|
|Други||за адаптивност виж разликите на присвояване и сравнение + използва се за подредени масиви||капризен алгоритъм|

Още:
- Алгортими, които правят големи скокове на елементи са нестабилни

Други алгоритми:
- Shake sort / Cocktail sort
- Shell's sort


|Име|Merge sort | Heap Sort | Quick Sort |
|---|---|---|---|
|Общ?|да|да|да|
|**Присвояване**||||
|*Best*|O(n*log(n))|O(n) [по създаване] + O(log(n)) |O|
|*Average*|O(n*log(n))|O(n) + O(n*log(n))|O(n*log(n))|
|*Worst*|O(n*log(n)) (\*)|O(n) + O(n*log(n))|O(n^2)|
|**Сравняване**||||
|*min*|O(n*log(n))|O(n) + O(n*log(n))|O(n*log(n))|
|*max*|O(n*log(n))  ![#f03c15](https://placehold.co/15x15/f03c15/f03c15.png)|O(n) + O(n*log(n))|O(n^2)|
|**памет**|O(n)(*)|O(1)|O(n)(*) (тази памет е за рекурсия) [ най-добрия случай поне O(n\*log(n))]|
|||||
|стабилност|да ![#f03c15](https://placehold.co/15x15/f03c15/f03c15.png)|не|не|
|частичност|не|да|да * (ако я ползваме? не знам какво съ мнаписал)|
|локалност|да|не|~да|
|поточност|не(*)|не|не|
|адаптивност|не|не| **анти** |
|устоичивост|да ![#f03c15](https://placehold.co/15x15/f03c15/f03c15.png)|силно ![#f03c15](https://placehold.co/15x15/f03c15/f03c15.png)|не|
|взависимост от контейнера|последователен достъп| пряк достъп|двупосочен|
|паралелизуемост|да  ![#f03c15](https://placehold.co/15x15/f03c15/f03c15.png)|не| да (*) (но ако трябва да се чака е зле)|
|Други|още n*log(n) памет заради рекурсията||изисква внимание|

Други алгоритми:
- Tree sort
- Младши-старши бит сорт

### за c++
``` cpp
std ::sort  //-> quick sort modified
std::stable_sort //-> заделя памет, ако се провали -> quick sort
std::partial_sort
```